<div class="center">
<div class="tabular">
<p><span>p<span>0.9</span></span><br />
<strong>Fiche IdentitÃ©:</strong></p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Discipline</th>
<th style="text-align: left;">MathÃ©matiques</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Auteur</td>
<td style="text-align: left;">Hector Blondel</td>
</tr>
<tr class="even">
<td style="text-align: left;">AnnÃ©e</td>
<td style="text-align: left;">2024-2025</td>    
</tr>
<tr class="odd">
<td style="text-align: left;">Cours concernÃ©</td>
<td style="text-align: left;">Traitement du signal</td>
</tr>
<tr class="even">
<td style="text-align: left;">Relu par</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><br />
</p>
</div>
</div>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>RÃ©sumÃ©:</strong></p>
<p>La transformÃ©e de Fourier discrÃ¨te se dÃ©finit naturellement et hÃ©rite
de propriÃ©tÃ©s similaires Ã  celles de la transformÃ©e de Fourier
classique. Elle peut-Ãªtre vue comme une opÃ©ration linÃ©aire (et donc
ayant sa matrice associÃ©e). Le formalisme matriciel permet de retrouver
beaucoup de propriÃ©tÃ©s de la transformÃ©e de Fourier discrÃ¨te, comme le
thÃ©orÃ¨me de convolution (la transformÃ©e de Fourier de la convolution
circulaire de deux vecteurs est Ã©galement le produit terme-Ã -terme des
transformÃ©es de Fourier de ces deux vecteurs)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Mots-clÃ©s</strong> : Traitement
numÃ©rique du signal, TransformÃ©e de Fourier, convolution circulaire,
matrice circulante</td>
</tr>
</tbody>
</table>
</div>
<h1 class="unnumbered" id="introduction">Introduction</h1>
<p>Que ce soit pour lâ€™analyse de signaux temporels, ou en
tÃ©lÃ©communications pour a transmission dâ€™information ou , la
transformation de Fourier est omniprÃ©sente dans la plupart des
applications dâ€™ingÃ©nieurie. Bien que notre monde soit physique et
continu, lâ€™ingÃ©nieur doit se rÃ©silier Ã  manipuler informatiquement des
signaux Ã  durÃ©e fini et Ã  temps discret. La transformÃ©e de Fourier
discrÃ¨te est alors nÃ©cessaire.</p>
<p>Nous nous proposons ici dâ€™introduire la transformÃ©e de Fourier
discrÃ¨te, sous un angle matriciel, en complÃ©mÃ©net du cours de premiÃ¨re
annÃ©e de traitement du signal de Centrale-SupÃ©lec. Cet angle permettra
au lecteur de visulaliser plus facilement ce qui se passe, et de pouvoir
vÃ©rifier ou redÃ©montrer facilement les propriÃ©tÃ©s.</p>
<div class="notations">
<p><strong>Notations 1</strong>. <em>Soit <span
class="math inline"><em>N</em>â€„âˆˆâ€„â„•</span>. Nous notons <span
class="math inline">â„³<sub><em>n</em></sub>(â„‚)</span> lâ€™ensemble des
matrices carrÃ©es de taille <span class="math inline"><em>N</em></span> Ã 
coefficients dans <span class="math inline">â„‚</span>. Les coefficients
des matrices seront indicÃ©s de <span class="math inline">0</span> Ã 
<span class="math inline"><em>N</em>â€…âˆ’â€…1</span> : <span
class="math inline">âˆ€(<em>i</em>,<em>j</em>)â€„âˆˆâ€„[â€Š[0,<em>N</em>âˆ’1]â€Š]<sup>2</sup></span>,
<span
class="math inline">[<em>M</em>]<sub><em>i</em>,â€†<em>j</em></sub></span>
dÃ©signe le coefficient <span
class="math inline"><em>i</em>,â€†<em>j</em></span> de <span
class="math inline"><em>M</em>â€„âˆˆâ€„â„³<sub><em>n</em></sub>(â„‚)</span> et
<span class="math inline"><em>x</em><sub><em>i</em></sub></span> dÃ©signe
le coefficient <span class="math inline"><em>i</em></span> du vecteur
<span
class="math inline"><em>x</em>â€„âˆˆâ€„â„‚<sup><em>N</em></sup></span>.</em></p>
</div>
<h1 id="matrices-circulantes">Matrices circulantes</h1>
<div class="tcolorbox">
<p>Lâ€™application <span class="math display">$$C : \begin{cases}
\mathbb{C}^N \to \mathcal{M}_N(\mathbb{C})  \\
x = (x_0, \ldots, x_{N-1}) \mapsto
\begin{bmatrix}
x_0 &amp; x_1 &amp; \cdots &amp; x_{N-1} \\
x_{N-1} &amp; x_0 &amp; \cdots &amp; x_{N-2} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_1 &amp; x_2 &amp; \cdots &amp; x_0 \\
\end{bmatrix}
\end{cases}$$</span> est un morphisme de groupe de <span
class="math inline">(â„‚<sup><em>N</em></sup>;+)</span> vers <span
class="math inline">(â„³<sub><em>N</em></sub>(â„‚),+)</span></p>
<p>Nous appelons "matrices circulantes" lâ€™image de C.</p>
</div>
<p>Par la suite, nous noterons <span class="math inline">ğ’</span>
lâ€™ensemble des matrices circulantes.</p>
<p>Les matrices circulantes permettent de reprÃ©senter algÃ©briquement
lâ€™opÃ©ration de convolution circulaire.</p>
<div class="definition">
<p><strong>DÃ©finition 2</strong>. <em><span>convolution
circulaire</span> Soient <span
class="math inline"><em>x</em>,â€†<em>y</em>â€„âˆˆâ€„â„‚<sup><em>N</em></sup></span>
deux vecteurs complexes. Le produit de convolution circulaire est le
vecteur de <span class="math inline">â„‚<sup><em>N</em></sup></span> dont
les coefficients sont :</em></p>
<p><em><span class="math display">$$(x \circledast y)_m =
\sum_{n=0}^{N-1} x_{m-n \mod N} y_{n}$$</span></em></p>
<p><em>Lâ€™opÃ©rateur C dÃ©fini plus haut nous permet dâ€™exprimer facilement
cette opÃ©ration :</em></p>
<p><em><span
class="math display"><em>x</em>â€…âŠ›â€…<em>y</em>â€„=â€„<em>C</em>(<em>x</em>)<sup><em>T</em></sup><em>y</em></span></em></p>
</div>
<h1 id="transformÃ©e-de-fourier-discrÃ¨te">TransformÃ©e de Fourier
discrÃ¨te</h1>
<h2 id="dÃ©finition">DÃ©finition</h2>
<p>Nous rappelons ci-dessous la dÃ©finition de la transformÃ©e de Fourier
discrÃ¨te.</p>
<div class="tcolorbox">
<p>La transformÃ©e de Fourier discrÃ¨te <span
class="math inline">â„±(<em>x</em>)</span> de <span
class="math inline"><em>x</em>â€„=â€„(<em>x</em><sub>0</sub>,<em>x</em><sub>1</sub>,...,<em>x</em><sub><em>N</em>â€…âˆ’â€…1</sub>)</span>
est la suite de k Ã©lÃ©ments : <span class="math inline">$\mathcal{F}(x)_k
= \tilde x_k = \sum_{n=0}^{N-1} x_n e^{-i\frac{2 \pi k
n}{N}}$</span></p>
</div>
<p>Posons <span class="math inline">$\omega = e^{- i
\frac{2\pi}{N}}$</span>. Nous notons <span class="math inline">$F =
\frac{1}{\sqrt{N}}\begin{bmatrix}  
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\
1 &amp; \omega &amp; \omega^{2} &amp; \cdots &amp; \omega^{N-1}\\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots\\
1 &amp; \omega^{N-1} &amp; \omega^{2(N-1)}&amp; \cdots&amp;
\omega^{(N-1)(N-1)}
\end{bmatrix}$</span> la matrice de Fourier. <span
class="math inline">[<em>F</em>]<sub><em>i</em>,â€†<em>j</em></sub>â€„=â€„<em>Ï‰</em><sup><em>i</em><em>j</em></sup></span>
: câ€™est la matrice de Van der Monde gÃ©nÃ©rÃ©e par les racines de lâ€™unitÃ©
dâ€™ordre N.</p>
<p>La transformÃ©e de Fourier sâ€™exprime simplement comme <span
class="math inline">$\tilde x = \sqrt{N} F x$</span>. Pour la suite,
nous utiliserons les propriÃ©tÃ©s de la matrice <span
class="math inline"><em>F</em></span> pour dÃ©montrer les propriÃ©tÃ©s de
la transformÃ©e de Fourier.</p>
<div id="prop:matrice_Fourier" class="property">
<p><strong>PropriÃ©tÃ© 3</strong> (proprietes de la matrice de Fourier).
<em></em></p>
<p><em><br />
</em></p>
<ul>
<li><p><em><span class="math inline"><em>F</em></span> est unitaire :
<span
class="math inline"><em>F</em><sup><em>H</em></sup><em>F</em>â€„=â€„<em>F</em><em>F</em><sup><em>H</em></sup>â€„=â€„<em>I</em><sub><em>N</em></sub></span></em></p></li>
<li><p><em><span class="math inline"><em>F</em></span> est symmmÃ©trique
: <span
class="math inline"><em>F</em><sup><em>T</em></sup>â€„=â€„<em>F</em></span></em></p></li>
</ul>
</div>
<div class="proof">
<p><em>Proof.</em> <span class="math inline">$\forall (i,j) \in
[\![0,N-1]\!]^2,  [F^H F]_{l,m} = \sum_{k=0}^{N-1} [F^*]_{k,l} [F]_{k,m}
= (\frac{1}{\sqrt{N}})^2 \sum_{k=0}^{N-1} e^{- i \frac{2 \pi k
(l-m)}{N}} = \frac{1}{N} N \delta [l-m] = \delta [l-m]$</span>Â â—»</p>
</div>
<p>Nous en dÃ©duisons directement lâ€™expression de la transformÃ©e de
Fourier discrÃ¨te inverse : <span class="math display">$$\mathcal{F} =
(\sqrt{N} F) \cdot \Rightarrow \mathcal{F}^{-1} = (\frac{1}{\sqrt{N}}
{F^*}) \cdot$$</span> (nous avons aussi <span
class="math inline">$\mathcal{F}^{-1} = \frac{1}{N}
\mathcal{F}^*$</span>)</p>
<div class="tcolorbox">
<p>Nous avons les propriÃ©tÃ© suivantes :</p>
<ul>
<li><p><strong>LinÃ©aritÃ©</strong> : <span
class="math inline">â„±{<em>a</em><em>x</em>â€…+â€…<em>b</em><em>y</em>}â€„=â€„<em>a</em><em>xÌƒ</em>â€…+â€…<em>b</em><em>yÌƒ</em></span>,
oÃ¹ <span class="math inline"><em>a</em></span> et <span
class="math inline"><em>b</em></span> sont des scalaires
complexes.</p></li>
<li><p><strong>SymÃ©trie hermitienne</strong> : <span
class="math inline"><em>x</em>â€„âˆˆâ€„â„â€„â‡’â€„<em>xÌƒ</em><sub>âˆ’<em>k</em></sub>â€„=â€„<em>xÌƒ</em><sub><em>k</em></sub><sup>*</sup>âˆ€<em>k</em>â€„âˆˆâ€„[â€Š[0,<em>N</em>âˆ’1]â€Š]</span></p></li>
<li><p><strong>DÃ©calage dans le temps</strong> : <span
class="math inline">$y_n = x_{n-m} \Rightarrow \mathcal{F}\{y\}_k =
\mathcal{F}\{x\}_k e^{-j \frac{2\pi k m}{N}}, \forall k \in
[\![0,N-1]\!]$</span>.</p></li>
<li><p><strong>Modulation</strong> : Si <span class="math inline">$y_n =
e^{j \frac{2\pi n m}{N}} x_n \Rightarrow \mathcal{F}\{y\}_k =
\mathcal{F}\{x\}_{k-m} \forall k \in [\![0,N-1]\!]$</span>.</p></li>
</ul>
<p>(Il est ici convenu que <span
class="math inline">âˆ€<em>k</em>â€„âˆˆâ€„â„•</span>, <span
class="math inline">â„±{<em>x</em>}<sub><em>k</em></sub>â€„:=â€„â„±{<em>x</em>}<sub><em>k</em>â€€modâ€†Â <em>N</em></sub></span>)</p>
</div>
<div class="property">
<p><strong>PropriÃ©tÃ© 4</strong>. <em>Toute matrice circulante <span
class="math inline"><em>X</em>â€„âˆˆâ€„ğ’</span> est diagonalisable dans la
base de Fourier ( <span class="math inline">$\begin{bmatrix}
1 \\
\omega^{k} \\
\omega^{2k}\\
... \\
\omega^{(N-1)k}
\end{bmatrix}$</span>, <span
class="math inline"><em>k</em>â€„âˆˆâ€„[â€Š[0,<em>N</em>âˆ’1]â€Š]</span>)</em></p>
<p><em>avec pour valeurs propres respectives les <span
class="math inline"><em>xÌƒ</em><sub><em>k</em></sub>,â€†<em>k</em>â€„âˆˆâ€„[â€Š[0,<em>N</em>âˆ’1]â€Š]</span>
:</em></p>
<p><em><span class="math display">$$X =  F \begin{bmatrix}
    \tilde x_0 &amp;  &amp;  &amp;  \\
      &amp; \tilde x_1 &amp;   &amp;  \\
     &amp;  &amp; \ddots &amp;  \\
     &amp;   &amp;  &amp; \tilde x_{N-1} \\
    \end{bmatrix} F^{-1} = F Diag(\tilde x)F^{-1}$$</span></em></p>
</div>
<div class="proof">
<p><em>Proof.</em> soit <span
class="math inline"><em>X</em>â€„=â€„<em>C</em>(<em>x</em><sub>0</sub>,â‹¯<em>x</em><sub><em>N</em>â€…âˆ’â€…1</sub>)</span>
une matrice circulante. Soit <span
class="math inline"><em>k</em>â€„âˆˆâ€„[â€Š[0,<em>N</em>âˆ’1]â€Š]</span>. Nous
avons</p>
<p><span class="math display">$$\begin{aligned}
_m = \sum_{n=0}^{N-1} x_{n-m \mod N} \omega^{nk}  \\
= \sum_{n=0}^{N-1} x_{n-m \mod N} \omega^{(n - m)k} \omega^{mk}
= \sum_{n=0}^{N-1} x_{n-m \mod N} \omega^{(n - m \mod N)k}\omega^{mk}
\end{aligned}$$</span>.</p>
<p>La derniÃ¨re Ã©galitÃ© vient du fait que <span
class="math inline"><em>Ï‰</em></span> est une racine N-iÃ¨me de lâ€™unitÃ©.
<span class="math display">$$\sum_{n=0}^{N-1} x_{n-m \mod N} \omega^{(n
- m \mod N)k} \omega^{mk} =  (\sum_{n=0}^{N-1} x_{n} \omega^{nk})
\omega^{mk} = \tilde x_k \omega^{mk}$$</span>.</p>
<p>Nous avons donc :</p>
<p><span class="math display">$$M \begin{bmatrix}
1 \\
\omega^{k} \\
\omega^{2k}\\
... \\
\omega^{(N-1)k}
\end{bmatrix}
= \tilde x_k \begin{bmatrix}
1 \\
\omega^{k} \\
\omega^{2k}\\
... \\
\omega^{(N-1)k}
\end{bmatrix}$$</span>, ce qui prouve bien que <span
class="math inline">$\begin{bmatrix}
1 \\
\omega^{k} \\
\omega^{2k}\\
... \\
\omega^{(N-1)k}
\end{bmatrix}$</span> est vecteur propre pour la valeur propre <span
class="math inline"><em>xÌƒ</em><sub><em>k</em></sub></span> de <span
class="math inline"><em>M</em></span>.</p>
<p>Puisque dâ€™aprÃ¨s <a href="#prop:matrice_Fourier"
data-reference-type="ref" data-reference="prop:matrice_Fourier">3</a>
ces <span class="math inline"><em>N</em></span> vecteurs sont
indÃ©pendants (<span class="math inline"><em>F</em></span> est
inversible), nous avons trouvÃ© une base de vecteur propres et les
matrices circulantes sont diagonalisables dans la base proposÃ©e.Â â—»</p>
</div>
<p>Nous pouvons rÃ©Ã©crire ce dernier rÃ©sultat de maniÃ¨re matricielle
:</p>
<p>La prÃ©cÃ©dente propriÃ©tÃ© nous permet de dÃ©montrer le thÃ©orÃ¨me de
convolution :</p>
<div class="tcolorbox">
<p>Soient <span class="math inline"><em>x</em></span> et <span
class="math inline"><em>y</em></span> deux vecteurs de <span
class="math inline">â„‚<sup><em>N</em></sup></span>. Nous avons : <span
class="math display">â„±{<em>x</em>â€…âŠ›â€…<em>y</em>}â€„=â€„â„±{<em>x</em>}â€…âŠ™â€…â„±{<em>y</em>}</span>
et <span class="math display">$$\mathcal{F}\{x \odot y \} = \frac{1}{N}
(\mathcal{F} \{x\} \circledast \mathcal{F} \{y\})$$</span>, oÃ¹ <span
class="math inline">âŠ™</span> dÃ©signe le produit de Hadamard (i.e.
coefficient par coefficient) entre deux vecteurs.</p>
</div>
<div class="proof">
<p><em>Proof.</em> Nous avons : <span
class="math display">$$x\circledast y = C(x)^T y = (F Diag(\tilde x)
F^{-1})^T y = F^{-1} Diag(\tilde x) F y \Rightarrow \sqrt{N} F (x
\circledast y) = Diag(\tilde x) \sqrt{N} F y$$</span>. Cela nous donne
donc bien, en identifiant terme Ã  terme :</p>
<p><span
class="math display">â„±{<em>x</em>â€…âŠ›â€…<em>y</em>}â€„=â€„(â„±{<em>x</em>})â€…âŠ™â€…(â„±{<em>y</em>})</span>
En prenant <span
class="math inline"><em>x</em>â€„=â€„â„±<sup>âˆ’1</sup>{<em>x</em>â€²}</span> et
<span
class="math inline"><em>y</em>â€„=â€„â„±<sup>âˆ’1</sup>{<em>y</em>â€²}</span> dans
lâ€™Ã©quation prÃ©cÃ©dente : <span class="math display">$$\begin{aligned}
x' \odot y' = \mathcal{F}\{\mathcal{F}^{-1}\{x'\} \circledast
\mathcal{F}^{-1}\{y'\}
\}  =  \mathcal{F}\{\frac{1}{N}\mathcal{F}^*\{x'\} \circledast
\frac{1}{N} \mathcal{F}^*\{y'\} \}
    \\
    \Rightarrow \frac{1}{N} \mathcal{F}^* \{x' \odot y'\}  =
\mathcal{F}^{-1} \{x' \odot y'\} = \frac{1}{N}\mathcal{F}^*\{x'\}
\circledast \frac{1}{N} \mathcal{F}^*\{y'\}  
\end{aligned}$$</span></p>
<p>oÃ¹ la derniÃ¨re ligne utilise que <span
class="math inline">$\mathcal{F}^{-1} = \frac{1}{N}
\mathcal{F}^*$</span>.</p>
<p>Finalement, nous obtenons le rÃ©sultat attendu en prenant le conjuguÃ©
et en multipliant par <span class="math inline">$\frac{1}{N}$</span> des
deux cÃ´tÃ©s de lâ€™Ã©galitÃ©.Â â—»</p>
</div>
<h2 id="transformÃ©es-de-fourier-discrÃ¨tes-usuelles">TransformÃ©es de
Fourier discrÃ¨tes usuelles</h2>
<div id="tab:2cols">
<table>
<caption>TransformÃ©es de Fourier discrÃ¨tes usuelles</caption>
<thead>
<tr class="header">
<th style="text-align: left;"><span
class="math inline"><em>x</em><sub><em>n</em></sub></span></th>
<th style="text-align: left;"><span
class="math inline"><em>xÌƒ</em><sub><em>k</em></sub>â€„=â€„â„±(<em>x</em>)<sub><em>k</em></sub></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span
class="math inline"><em>x</em><sub><em>n</em></sub>â€„=â€„<em>Î´</em><sub><em>n</em><sub>0</sub></sub>[<em>n</em>]</span></td>
<td style="text-align: left;"><span class="math inline">$\tilde x_k =
e^{i\frac{2\pi n_0 n}{N}}$</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">$x_n = e^{i
\frac{2 \pi k_0 n}{N}}$</span></td>
<td style="text-align: left;"><span
class="math inline"><em>xÌƒ</em><sub><em>k</em></sub>â€„=â€„<em>Î´</em><sub><em>k</em><sub>0</sub></sub>[<em>k</em>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">$\frac{1}{n_0}
1_{[\![0,n_0 - 1]\!]}[n]$</span></td>
<td style="text-align: left;"><span class="math inline">$e^{-i \pi
\frac{k (n_0-1)}{N}} \frac{\sin{\frac{\pi k n_0}{N}}}{n_0 \sin{\pi
\frac{k}{N}}}$</span></td>
</tr>
</tbody>
</table>
</div>
<p>Cette derniÃ¨re fonction est lâ€™Ã©quivalent discret du sinus cardinal
continu. Nous avons tracÃ© une reprÃ©sentation graphique ci-dessous :</p>
<figure id="fig:mainfigure">
<figure id="fig:subfigure1">
<img src="sinus_cardinal_decentre.png" />
<figcaption><span
class="math inline"><em>k</em>â€„âˆˆâ€„[â€Š[0,<em>N</em>âˆ’1]â€Š]</span></figcaption>
</figure>
<figure id="fig:subfigure2">
<img src="sinus_cardinal_centre.png" />
<figcaption><span class="math inline">$k \in [\![-\frac{N}{2},
\frac{N}{2} - 1]\!]$</span></figcaption>
</figure>
<figcaption>tracÃ© de <span class="math inline">$k \mapsto
\frac{\sin(\frac{\pi k n_0}{N})}{n_0 \sin(\frac{\pi
k}{N})}$</span></figcaption>
</figure>
<p>Il est plus naturel de reprÃ©senter le sinus cardinal nÃ©gatif sur
<span class="math inline">$[\![-\frac{N}{2},\frac{N}{2} - 1]\!]$</span>.
Par pÃ©riodicitÃ©, il sâ€™agit dâ€™une rotation cyclique des valeurs sur <span
class="math inline">[â€Š[0,<em>N</em>âˆ’1]â€Š]</span>.</p>
<p><u>Exercice :</u> Montrer que la transformÃ©e de Fourier discrÃ¨te de
la suite finie <span class="math inline">$( \begin{pmatrix}
N-1 \\
n
\end{pmatrix})_n$</span> est <span class="math inline">$((1+e^{i\frac{2
\pi k}{N}})^{N-1})_k$</span></p>
<h1 id="implÃ©mentation-algorithmique-et-applications">ImplÃ©mentation
algorithmique et applications</h1>
<h2
id="implÃ©mentation-fast-fourier-transform-transformÃ©e-de-fourier-rapide">ImplÃ©mentation
: Fast Fourier Transform, transformÃ©e de Fourier rapide</h2>
<p>Le calcul naÃ¯f de la transformÃ©e de Fourier discrÃ¨te recquiert de
lâ€™ordre de <span class="math inline"><em>N</em><sup>2</sup></span>
opÃ©rations (multiplications ou additions complexes) : pour chaque indice
de frÃ©quence <span class="math inline"><em>k</em></span>, il faut
calculer la somme des <span class="math inline"><em>N</em></span>
composantes <span class="math inline">$(x_n e^{-i\frac{2\pi
kn}{N}})_n$</span>.</p>
<p>Lâ€™idÃ©e principale de la FFT repose sur une dÃ©composition rÃ©cursive du
calcul de la DFT. En divisant le signal dâ€™entrÃ©e en sous-sÃ©quences de
tailles plus petites, on peut rÃ©duire le nombre dâ€™opÃ©rations
nÃ©cessaires.</p>
<p>Pour simplifier, supposons que <span
class="math inline"><em>N</em></span> est une puissance de 2. On peut
Ã©crire <span class="math inline"><em>x</em><sub><em>n</em></sub></span>
comme la somme de deux sÃ©quences : <span
class="math display"><em>x</em><sub><em>n</em></sub>â€„=â€„<em>x</em><sub>pair</sub>(<em>n</em>)â€…+â€…<em>x</em><sub>impair</sub>(<em>n</em>)</span>
avec : <span
class="math display"><em>x</em><sub>pair</sub>(<em>m</em>)â€„=â€„<em>x</em><sub>2<em>m</em></sub>,â€Šâ€<em>x</em><sub>impair</sub>(<em>m</em>)â€„=â€„<em>x</em><sub>2<em>m</em>â€…+â€…1</sub>.</span></p>
<p>La DFT peut alors Ãªtre exprimÃ©e comme : <span
class="math display">$$\begin{aligned}
\tilde x_k = \sum_{m=0}^{N/2-1} x_{2m} e^{-i \frac{2\pi}{N} k(2m)} +
\sum_{m=0}^{N/2-1} x_{2m+1} e^{-i \frac{2\pi}{N} k(2m+1)}.
\\ = \sum_{m=0}^{N/2-1} x_{2m} e^{-i \frac{2\pi}{N/2} km} + e^{-i
\frac{2\pi}{N} k} \sum_{m=0}^{N/2-1} x_{2m+1} e^{-i \frac{2\pi}{N/2}
km}.
\end{aligned}$$</span></p>
<p>Pour <span class="math inline"><em>k</em>âˆˆ</span></p>
<p>En factorisant, cela donne :</p>
<p>Pour <span
class="math inline"><em>k</em>â€„âˆˆâ€„[â€Š[0,<em>N</em>/2âˆ’1]â€Š]</span>,</p>
<p><span class="math display">$$\begin{cases} \tilde x_k
=  \sum_{m=0}^{N/2-1} x_{2m} e^{-i \frac{2\pi}{N/2} km} + e^{-i
\frac{2\pi}{N} k} \sum_{m=0}^{N/2-1} x_{2m+1} e^{-i \frac{2\pi}{N/2}
km}.  \\
\tilde x_{\frac{N}{2} + k} = \sum_{m=0}^{N/2-1} x_{2m} e^{-i
\frac{2\pi}{N/2} km} + e^{-i \pi} e^{-i \frac{2\pi}{N} k}
\sum_{m=0}^{N/2-1} x_{2m+1} e^{-i \frac{2\pi}{N/2} km}
\end{cases}$$</span></p>
<p><span class="math display">$$\Rightarrow \begin{cases} \tilde x_k
=  \tilde x_k^{\text{pair}} + e^{-i \frac{2\pi}{N} k} \tilde
x_k^{\text{impair}}  \\
\tilde x_{\frac{N}{2} + k} = \tilde x_k^{\text{pair}} - e^{-i
\frac{2\pi}{N} k} \tilde x_k^{\text{impair}}
\end{cases}$$</span></p>
<p>oÃ¹ <span
class="math inline"><em>xÌƒ</em><sub><em>k</em></sub><sup>pair</sup></span>
et <span
class="math inline"><em>xÌƒ</em><sub><em>k</em></sub><sup>impair</sup></span>
sont les TFDs des sous-sÃ©quences de taille <span
class="math inline"><em>N</em>/2</span>.</p>
<p>Le processus se poursuit en dÃ©composant chaque sous-sÃ©quence jusquâ€™Ã 
obtenir des sÃ©quences de taille 1, pour lesquelles la TFD est la valeur
du coefficient. Si nous notons <span
class="math inline"><em>T</em>(<em>N</em>)</span> la complexitÃ© du
calcul de la TFD sur une liste de taille <span
class="math inline"><em>N</em></span> par lâ€™algorithme de Cooley-Tuckey,
nous avons :</p>
<p><span class="math display">$$\begin{cases}
    T(N) = 2T(\frac{N}{2}) + N \\
    T(1) = 0
\end{cases}$$</span></p>
<p>Le premier terme correspond au calcul des DFT des deux
sous-sÃ©quences. Le deuxiÃ¨me terme de la somme correspond au calcul des
<span class="math inline"><em>xÌƒ</em><sub><em>k</em></sub></span> en
fonction de ces derniÃ¨res valeurs.</p>
<p>En posant <span
class="math inline"><em>p</em>â€„=â€„log<sub>2</sub><em>N</em></span> et
<span
class="math inline"><em>S</em>(<em>p</em>)â€„=â€„<em>T</em>(<em>N</em>=2<sup><em>p</em></sup>)</span>,
lâ€™Ã©quation de complexitÃ© devient :</p>
<p><span class="math display">$$\begin{cases}
S(p) = 2 S(p-1) + 2^p \\
S(0) = 0
\end{cases}$$</span></p>
<p>Une rÃ©currence immÃ©diate donne :</p>
<p><span
class="math display"><em>S</em>(<em>p</em>)â€„=â€„<em>p</em>2<sup><em>p</em></sup>â€„â‡’â€„<em>T</em>(<em>N</em>)â€„=â€„<em>S</em>(log<sub>2</sub><em>N</em>)â€„=â€„<em>N</em>log<sub>2</sub><em>N</em></span>.</p>
<p>Cela est meilleur que la complexitÃ© naÃ¯ve (de <span
class="math inline"><em>N</em><sup>2</sup></span>).</p>
<h2 id="application-produit-de-convolution-rapide">Application : produit
de convolution rapide</h2>
<p>Soient <span
class="math inline"><em>x</em>â€„âˆˆâ€„â„‚<sup><em>p</em></sup></span> et <span
class="math inline"><em>y</em>â€„âˆˆâ€„â„‚<sup><em>q</em></sup></span> deux
vecteurs. Nous souhaitons calculer la convolution (discrÃ¨te) <span
class="math display">$$x \ast y = (\sum_{k=0}^{p-1} x_k y_{m-k})_{0 \leq
m &lt; p + q}$$</span> (oÃ¹ <span
class="math inline"><em>x</em><sub><em>k</em></sub>â€„=â€„0</span> lorsque
<span class="math inline"><em>k</em>â€„âˆ‰â€„[â€Š[0,<em>p</em>âˆ’1]â€Š]</span> et
<span class="math inline"><em>y</em><sub><em>k</em></sub>â€„=â€„0</span>
lorsque <span
class="math inline"><em>k</em>â€„âˆ‰â€„[â€Š[0,<em>q</em>âˆ’1]â€Š]</span> .</p>
<p>Le calcul naÃ¯f nÃ©cessite de lâ€™ordre de <span
class="math inline">ğ’ª(<em>p</em><em>q</em>)</span> opÃ©rations
Ã©lÃ©mentaires.</p>
<p>Le thÃ©orÃ¨me deconvolution nous permet de rÃ©duire facilement la
complexitÃ© cu calcul de <span
class="math inline"><em>x</em>â€…*â€…<em>y</em></span> : remarquons quâ€™un
produit de convolution classique est une convolution circulaire si lâ€™on
Ã©tend suffisemment le support des vecteurs.</p>
<p>Posons <span
class="math inline"><em>N</em>â€„=â€„<em>p</em>â€…+â€…<em>q</em>â€…âˆ’â€…1</span> et
notons respectivement <span
class="math inline"><em>x</em><sup>(<em>N</em>)</sup></span> et <span
class="math inline"><em>y</em><sup>(<em>N</em>)</sup></span> les
vecteurs Ã©tendus de <span class="math inline"><em>x</em></span> et <span
class="math inline"><em>y</em></span> avec <span
class="math inline"><em>N</em></span> Ã©lÃ©ments (avec <span
class="math inline">$x^{(N)} = \begin{bmatrix}
    x ~ 0 \cdots 0
\end{bmatrix}$</span> et <span class="math inline">$y^{(N)} =
\begin{bmatrix}
    y ~  0 \cdots 0
\end{bmatrix}$</span>). <span
class="math display"><em>x</em>â€…*â€…<em>y</em>â€„=â€„<em>x</em><sup>(<em>N</em>)</sup>â€…âŠ›â€…<em>y</em><sup>(<em>N</em>)</sup>â€„=â€„â„±<sup>âˆ’1</sup>{â„±(<em>x</em><sup>(<em>N</em>)</sup>}âŠ™â„±{<em>y</em><sup>(<em>N</em>)</sup>)}</span></p>
<p>Cette mÃ©thodes nÃ©cessite les opÃ©rations suivantes:</p>
<ul>
<li><p>Calcul des deux transformÃ©es de Fourier (<span
class="math inline">ğ’ª(<em>N</em>log<sub>2</sub>(<em>N</em>)</span>))</p></li>
<li><p>Produit de Hadamard (<span
class="math inline">ğ’ª(<em>N</em>)</span>)</p></li>
<li><p>TransformÃ©e de Fourier inverse (<span
class="math inline">ğ’ª(<em>N</em>log<sub>2</sub><em>N</em>)</span>)</p></li>
</ul>
<p>La complexitÃ© de cette nouvelle mÃ©thode est en <span
class="math inline">ğ’ª((<em>p</em>+<em>q</em>)log<sub>2</sub>(<em>p</em>+<em>q</em>))â€„â‰ªâ€„ğ’ª(<em>p</em><em>q</em>)</span>,
elle accÃ©lÃ¨re significativement le calcul de la convolution.</p>
<p>En python, la fonction <code>scipy.signal.convolve</code> du package
<code>scipy</code> utilise lâ€™astuce que nous venons dâ€™exposer pour
calculer de la convolution entre deux tableaux.</p>
<p>Les calculs de produits polynÃ´mes relevant Ã©galement du calcul de
convolution, ou les produits dâ€™entiers peuvent Ã©galement grandement Ãªtre
amÃ©liorÃ©s avec cette mÃ©thode.</p>
<h1 id="memo">Memo</h1>
<div class="tcolorbox">
<ul>
<li><p><strong>DÃ©finition :</strong> <span
class="math display">$$\mathcal{F}(x)_k = \tilde x_k = \sum_{n=0}^{N-1}
x_n e^{-i\frac{2 \pi k n}{N}}$$</span> <span
class="math display">$$\mathcal{F}^{-1}(\tilde x)_n = x_n =
\sum_{k=0}^{N-1} x_k e^{i\frac{2 \pi n k}{N}}$$</span></p></li>
<li><p><strong>LinÃ©aritÃ© :</strong> <span
class="math display">â„±{<em>a</em><em>x</em>â€…+â€…<em>b</em><em>y</em>}â€„=â€„<em>a</em><em>xÌƒ</em>â€…+â€…<em>b</em><em>yÌƒ</em></span>
oÃ¹ <span class="math inline"><em>a</em>,â€†<em>b</em>â€„âˆˆâ€„â„‚</span>.</p></li>
<li><p><strong>SymÃ©trie hermitienne :</strong> <span
class="math display"><em>x</em>â€„âˆˆâ€„â„â€„â‡’â€„<em>xÌƒ</em><sub>âˆ’<em>k</em></sub>â€„=â€„<em>xÌƒ</em><sub><em>k</em></sub><sup>*</sup>â€Šâ€âˆ€<em>k</em>â€„âˆˆâ€„[â€Š[0,<em>N</em>âˆ’1]â€Š]</span></p></li>
<li><p><strong>DÃ©calage dans le temps :</strong> <span
class="math display">$$y_n = x_{n-m} \Rightarrow \mathcal{F}\{y\}_k =
\mathcal{F}\{x\}_k e^{-j \frac{2\pi k m}{N}}$$</span></p></li>
<li><p><strong>Modulation :</strong> <span class="math display">$$y_n =
e^{j \frac{2\pi n m}{N}} x_n \Rightarrow \mathcal{F}\{y\}_k =
\mathcal{F}\{x\}_{k-m}$$</span></p></li>
<li><p><strong>Convolution :</strong> <span
class="math display">â„±{<em>x</em>â€…âŠ›â€…<em>y</em>}â€„=â€„â„±{<em>x</em>}â€…âŠ™â€…â„±{<em>y</em>}</span>
<span class="math display">$$\mathcal{F}\{x \odot y \} = \frac{1}{N}
\mathcal{F} \{x\} \circledast \mathcal{F} \{y\}$$</span></p></li>
</ul>
</div>
